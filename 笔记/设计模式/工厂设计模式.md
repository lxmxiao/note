# 工厂设计模式
为什么要用工厂模式
1. 解耦：把对象的创建和使用的过程分开
2. 降低代码重复：如果创建某个对象的过程都很复杂，需要一定的代码量，而且很多地方都要用到，那么就会有很多的重复代码
3. 降低维护成本：由于创建过程都由工厂统一管理，所以发生业务逻辑变化，不需要找到所有需要创建某个对象的地方去逐个修正，值需要在工厂里修改即可，降低维护成本
## 简单工厂模式(静态工厂方法模式)
适用场景
1. 需要创建的对象较少
2. 客户端不关心对象的创建过程
角色分配
1. 工厂角色：简单工厂模式的核心，它负责实现创建所有实例的内部逻辑。工厂类可以被外界直接调用，创建所需的产品对象
2. 抽象产品角色：简单工厂模式所创建的所有对象的父类，它负责描述所有实例所共有的公共接口
3. 具体产品角色：简单工厂模式的创建目标，所有创建的对象都是充当这个角色的某个具体类的实例
使用
    一般情况下正常的简单工厂模式使用次数很少，因为违背了开方-封闭原则
    但可以使用反射机制改善简单工厂
```java
public class ShapeFactory {
    public static Object getClass(Class<? extends Shape> clazz){
        Object obj = null;
        try{
            obj = Class.forName(clazz.getName().newInstance());
        }catch(ClassNotFoundException e){
            e.printStackTrace();
        }catch(InstantiationException e){
            e.printStackTrace();
        }catch(IllegalAccessException  e){
            e.printStackTrace();
        }
        return obj;
    }
}
```
这种方式虽然符合了开方-关闭原则，但是每一次传入的都是产品类的全部路径，这样比较麻烦

简单工厂模式改善(反射+配置文件)

如果需要改善的话可以通过反射+配置文件的形式来改善，这种方式使用的也是比较多的
## 工厂方法模式
介绍
    工厂方法模式就是说每个对象都有一个与之对应的工厂
    为不同产品，提供不同的生产方法
使用场景
* 一个类不知道它所需要的对象的类
    在工厂方法模式中，客户端不需要知道具体产品类的类名，只需要知道所对应的工厂即可，具体的产品对象由具体工厂类创建；客户端需要知道创建具体产品的工厂类
* 一个类通过其子类来指定创建哪个对象
    在工厂方法模式中，对于抽象工厂类只需要提供一个创建产品的接口，而由其子类来确定具体要创建的对象，利用面向对象的多态性和里氏
* 将创建对象的任务委托黑多个工厂子类中的某一个
    客户端在使用时可以无需关心是哪一个工厂子类创建产品子类，需要时再动态指定，可将具体工厂类的类名存储在配置文件或数据库中
代码
```java
//生产三个动物类对象
public class Factory{
    public static Animal createCat(){
        return new Cat();
    }
    public static Animal createCat(){
        return new Dog();
    }
    public static Animal createCat(){
        return new Pig();
    }
}
```
好处：方便创建 同种类型的 复杂参数 对象
    使用方便、容错率高
    工厂方法的好处就是更拥抱变化。当需求变化，只需要增删相应的类，不需要修改已有的类。
