## 什么是成本

在 `MySQL` 中一条查询语句的执行成本是由下边这两个方面组成的：

* `I/O` 成本

  经常使用的 `MyISAM` 、 `InnoDB` 存储引擎都是将数据和索引都存储到磁盘上的，当我们想查询表中的记录时，需要先把数据或者索引加载到内存中然后再操纵。这个从磁盘到内存这个加载的过程损耗的时间称之为 `I/O` 成本

* `CPU` 成本

  读取以及检测记录是否满足对应的搜索条件、对结果集进行排序等这些操作损耗的时间称之为 `CPU` 成本

对于 `InnoDB` 存储引擎来说，页时磁盘和内存之前交互的基本单位， `MySQL` 的设计者规定读取一个页面花费的成本默认是 `1.0` ，读取以及检测一条记录是否符合搜索条件的成本默认是 `0.2` 。 `1.0` 、 `0.2` 这些数字称之为 `成本常数` ，这两个成本常数我们最常用到

## 单表查询的成本

### 准备

首先创建一个表 `single_table`，用来解释：

```sql
CREATE TABLE single_table (
    id INT NOT NULL AUTO_INCREMENT,
    key1 VARCHAR(100),
    key2 INT,
    key3 VARCHAR(100),
    key_part1 VARCHAR(100),
    key_part2 VARCHAR(100),
    key_part3 VARCHAR(100),
    common_field VARCHAR(100),
    PRIMARY KEY (id),
    KEY idx_key1 (key1),
    UNIQUE KEY idx_key2 (key2),
    KEY idx_key3 (key3),
    KEY idx_key_part(key_part1, key_part2, key_part3)
) Engine=InnoDB CHARSET=utf8;
```

假设这个表里又10000条记录，除 `id` 列外其余的列都插入随机值

### 基于成本的优化步骤

在一条单表查询语句真正执行之前，`MySQL` 的查询优化器会找出执行该语句所有可能使用的方案，对比之后找出成本最低的方案，这个成本最低的方案就是所谓的 `执行计划` ，之后才会调用存储引擎提供的接口真正的执行查询，这个过程总结一下就是这样：

1. 根据搜索条件，找出所有可能使用的索引
2. 计算全表扫描的代价
3. 计算使用不同索引执行查询的代价
4. 对比各种执行方案的代价，找出成本最低的那一个

下边就以一个实例拉分析一下这些步骤，单表查询语句如下：

```sql
SELECT * FROM single_table WHERE 
    key1 IN ('a', 'b', 'c') AND 
    key2 > 10 AND key2 < 1000 AND 
    key3 > key2 AND 
    key_part1 LIKE '%hello%' AND
    common_field = '123';
```

**1.根据搜索条件，找出所有可能使用的索引**

对于 `B+` 树索引来说，只要索引列和常数使用 `=`、`<=>`、`IN`、`NOT IN`、`IS NULL`、`IS NOT NULL`、`>`、`<`、`>=`、`<=`、`BETWEEN`、`!=` （不等于也可以写成 `<>` ）或者 `LIKE` 操作符连接起来，就可以产生一个所谓的 `范围区间` （ `LIKE` 匹配字符串前缀也行） ，也就是说这些搜索条件都可能使用到索引， `MySQL` 的设计者把一个查询中可能使用到的索引称之为 `possible keys`

分析一下上边查询中涉及到的几个搜索条件：

* `key1 IN('a','b','c')` ，这个搜索条件可以使用二级索引 `idx_key1`
* `key2 > 10 AND key2 < 1000`，这个搜索条件可以使用二级索引 `idx_key2`
* `key3 > key2` ，这个搜索条件的索引列由于没有和常数比较，所以并不能使用到索引
* `key_part1 LIKE '%hello%'`，`key_part1` 通过 `LIKE` 操作符和以通配符开头的字符串做比较，不可以适用索引
* `common_field = '123'`，由于该列上压根没有索引，所以不会用到索引

综上所述，上边的查询语句可能用到的索引，也就是 `possible keys` 只有 `idx_key1` 和 `idx_key2`

**2.计算全表扫描的代价**

对于 `InnoDB` 存储引擎来说，全表扫描的意思就是把聚簇索引中的记录都依次和给定的搜索条件做一下比较，把符合搜索条件的记录加入到结果集，所以需要将聚簇索引对应的页面加载到内存中，然后再检测记录是否符合搜索条件。由于查询成本= `I/O` 成本+ `CPU` 成本，所以计算全表扫描的代价需要两个信息：

* 聚簇索引占用的页面数
* 该表中的记录树

`MySQL `的设计者为每个表的维护了一系列的 `统计信息` ：

```sql
SHOW TABLE STATUS LIKE 'single_table'
```

```sql
mysql> USE xiaohaizi;
Database changed

mysql> SHOW TABLE STATUS LIKE 'single_table'\G
*************************** 1. row ***************************
           Name: single_table
         Engine: InnoDB
        Version: 10
     Row_format: Dynamic
           Rows: 9693
 Avg_row_length: 163
    Data_length: 1589248
Max_data_length: 0
   Index_length: 2752512
      Data_free: 4194304
 Auto_increment: 10001
    Create_time: 2018-12-10 13:37:23
    Update_time: 2018-12-10 13:38:03
     Check_time: NULL
      Collation: utf8_general_ci
       Checksum: NULL
 Create_options:
        Comment:
1 row in set (0.01 sec)
```

* `Rows`

  本选项表示表中的记录条数。对于使用 `MyISAM` 存储引擎的表来说，该值是准确的，对于使用 `InnoDB` 存储引擎的表来说，该值是一个估计值。从查询结果我们也可以看出来，由于我们的 `single_table` 表是使用 `InnoDB` 存储引擎的，所以虽然实际上表中有10000条记录，但是 `SHOW TABLE STATUS` 显示的 `Rows` 值只有9693条记录

* `Data_length`

  本选项表示表占用的存储空间字节数。使用 `MyISAM` 存储引擎的表来说，该值就是数据文件的大小，对于使用 `InnoDB` 存储引擎的表来说，该值就相当于聚簇索引占用的存储空间大小，我们的 `single_table` 使用默认 `16KB` 的页面大小，而上边查询结果显示 `Data_length` 的值是 `1589248` ，所以可以来推导出 `聚簇索引的页面数量`：

  ```
  聚簇索引的页面数量 = 1589248 ÷ 16 ÷ 1024 = 97
  ```


现在已经得到了聚簇索引占用的页面数量以及该表记录数的估计值，所以就可以计算全表扫描成本了，但是 `MySQL` 的设计者在真实计算成本时会进行一些 `微调` ，可以看下全表扫描成本的计算过程：

* `I/O` 成本

  ```
  97 x 1.0 + 1.1 = 98.1
  ```

  `97` 指的时聚簇索引占用的页面数，`1.0` 指的是加载一个页面的成本常数，后边的 `1.1` 是一个微调值

* `CPU` 成本：

  ```
  9693 x 0.2 + 1.0 = 1939.6
  ```

  `9693` 指的是统计数据中表的记录数，对于 `InnoDB` 存储引擎来说是一个估计值，`0.2` 指的是访问一条记录所需的成本常速，后边的 `1.0` 是一个微调值

* 总成本

  ```
  98.1 + 1939.6 = 2037.7
  ```

综上所述，对于 `single_table` 的全表扫描所需的总成本就是 `2037.7`

## 连接查询的成本

### Condition filtering介绍

`MySQL` 中连接查询采用的是嵌套循环连接算法，驱动表会被访问一次，被驱动表可能被访问多次，所以对于两表连接查询来说，它的查询成本由下边两个部分构成：

* 单次查询驱动表的成本
* 多次查询被驱动表的成本（<font color=red>具体查询多少次取决于对驱动表查询的结果集中有多少条记录</font>）

把对驱动表进行查询后得到的记录条数称之为驱动表的 `扇出` （英文名：`fanout`）。很显然驱动表的扇出值越小，对被驱动表的查询次数也就越少，连接查询的总成本也就越低。当查询优化器想计算整个连接查询所使用的成本时，就需要计算出驱动表的扇出值

一般情况下，扇出值都可以直接算出来，但在下面这两种情况下计算驱动表扇出值需要靠 `猜`：

* 如果使用的是全表扫描的方式执行的单表查询，那么计算驱动表扇出时需要猜满足搜索条件的记录到底有多少条
* 如果使用的是索引执行的单表扫描，那么计算驱动表扇出的时候需要猜满足除使用到对应索引的搜索条件外的其他搜索条件的记录有多少条

`MySQL` 的设计者把这个 `猜` 的过程称之为 `condition filtering` 

### 两表连接的成本分析

连接查询的成本计算公式是这样的：

> 连接查询总成本 = 单词访问驱动表的成本 + 驱动表扇出数 x 单词访问被驱动表的成本

对于左（外）连接和右（外）连接查询来说，他们的驱动表是固定的，所以想要得到最优的查询方案只需要：

* 分别为驱动表和被驱动表选择成本最低的访问方法

可是对于内连接来说，驱动表和被驱动表的位置是可以互换的，所以需要考虑两个方面的问题：

* 不同的表作为驱动表最终的查询成本可能是不同的，也就是需要考虑最优的表连接顺序
* 然后分别为驱动表和被驱动表选择成本最低的访问方法

一般情况下，连接查询成本占大头的是 <font color=red>`驱动表扇出数 x 单词访问被驱动表的成本`</font> ，所以需要优化的重点是下边这两个部分：

* 尽量减少驱动表的扇出

* 对被驱动表的访问成本尽量低

  这一点对于实际书写连接查询语句时十分有用，需要<font color=red>尽量在被驱动表的连接列上建立索引</font>，这样就可以使用 <font color=red>`ref`</font> 访问方法来降低访问被驱动表的成本了。<font color=red>如果可以，被驱动表的连接列最好是该列表的主键或者唯一二级索引列</font>，这样就可以把访问被驱动表的成本降到更低了

### 多表连接的成本分析

首先要考虑一下多表连接时可能产生出多少种连接顺序：两表时为2种；三表时为6种；四表时为24种；当n表时，则有 `n × (n-1) × (n-2) × ··· × 1` 种连接顺序，也就是 `n!`

如果有 `n` 个表进行连接，`MySQL` 会把每一种连接顺序的成本都算一遍，不过其中用了很多种减少连接顺序的成本的方法：

- 提前结束某种顺序的成本评估

  `MySQL` 在计算各种链接顺序的成本之前，会维护一个全局的变量，这个变量表示当前最小的连接查询成本。如果在分析某个连接顺序的成本时，该成本已经超过当前最小的连接查询成本，那就压根儿不对该连接顺序继续往下分析了。比方说A、B、C三个表进行连接，已经得到连接顺序 `ABC` 是当前的最小连接成本，比方说 `10.0` ，在计算连接顺序 `BCA` 时，发现 `B` 和 `C` 的连接成本就已经大于 `10.0` 时，就不再继续往后分析 `BCA` 这个连接顺序的成本了

- 系统变量 `optimizer_search_depth`

  为了防止无穷无尽的分析各种连接顺序的成本， `MySQL` 的设计者提出了 `optimizer_search_depth` 系统变量，如果连接表的个数小于该值，那么就继续穷举分析每一种连接顺序的成本，否则只对与 `optimizer_search_depth` 值相同数量的表进行穷举分析。很显然，该值越大，成本分析的越精确，越容易得到好的执行计划，但是消耗的时间也就越长，否则得到不是很好的执行计划，但可以省掉很多分析连接成本的时间

- 根据某些规则压根儿就不考虑某些连接顺序

  即使是有上边两条规则的限制，但是分析多个表不同连接顺序成本花费的时间还是会很长，所以 `MySQL` 的设计者干脆提出了一些所谓的 `启发式规则` （就是根据以往经验指定的一些规则），凡是不满足这些规则的连接顺序压根儿就不分析，这样可以极大的减少需要分析的连接顺序的数量，但是也可能造成错失最优的执行计划。他们提供了一个系统变量 `optimizer_prune_level` 来控制到底是不是用这些启发式规则