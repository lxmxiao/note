## 连接简介

### 连接的本质

首先建立两个表并填充一些数据：

```sql
mysql> CREATE TABLE t1 (m1 int, n1 char(1));
Query OK, 0 rows affected (0.02 sec)

mysql> CREATE TABLE t2 (m2 int, n2 char(1));
Query OK, 0 rows affected (0.02 sec)

mysql> INSERT INTO t1 VALUES(1, 'a'), (2, 'b'), (3, 'c');
Query OK, 3 rows affected (0.00 sec)
Records: 3  Duplicates: 0  Warnings: 0

mysql> INSERT INTO t2 VALUES(2, 'b'), (3, 'c'), (4, 'd');
Query OK, 3 rows affected (0.00 sec)
Records: 3  Duplicates: 0  Warnings: 0
```

我们成功建立了 `t1`、`t2` 两个表，这两个表都有两个列，一个是 `INT` 类型的，一个是 `CHAR(1)` 类型的，填充好数据的两个表长这样：

```sql
mysql> SELECT * FROM t1;
+------+------+
| m1   | n1   |
+------+------+
|    1 | a    |
|    2 | b    |
|    3 | c    |
+------+------+
3 rows in set (0.00 sec)

mysql> SELECT * FROM t2;
+------+------+
| m2   | n2   |
+------+------+
|    2 | b    |
|    3 | c    |
|    4 | d    |
+------+------+
3 rows in set (0.00 sec)
```

### 连接过程简介

在连接查询中的过滤条件可以分为两种：

* 涉及单表的条件

  这种只涉及单表的过滤条件之前称之为 `搜索条件` 比如 `t1.m1 > 1` 是只针对 `t1` 表的过滤条件， `t.n2 < 'd'` 是只针对 `t2` 表的过滤条件

* 涉及两表的条件

  比如 `t1.m1 = t2.m2` 、`t1.n1 > t2.n2` 等

下面看一下携带过滤条件的连接查询的大致执行过程，比如说：

```sql
SELECT * FROM t1, t2 WHERE t1.m1 > 1 AND t1.m1 = t2.m2 AND t2.n2 < 'd';
```

这个连接查询的大致执行过程如下：

1. ![img](连接的原理.assets\167e43ab3dfab5ed)

   第一个需要查询的表称之为 `驱动表` 

2. ![img](连接的原理.assets\167e43ab3a02660b)

   由于是根据 `t1` 表中的记录去找 `t2` 表中的记录，所以 `t2` 表也可以被称之为 `被驱动表`

从上边可以看出这个两表连接查询共需要查询1次 `t1` 表，2次 `t2` 表。当然这是在特定的过滤条件下的结果，如果我们把 `t1.m1 > 1` 这个条件去掉，那么从 `t1` 表中查出的记录就有3条，就需要查询3次 `t2` 表。也就是说在两表连接查询中，驱动表只需要访问一次，被驱动表能被访问多次

### 内连接和外连接

* 对于 `内连接` 的两个表，驱动表中的记录在被驱动表中找不到匹配的记录，该记录不会加入到最后的结果集

* 对于 `外连接` 的两个表，驱动表中的记录即使在被驱动表中没有匹配的记录，也仍然需要加入到结果集

  在 `MySQL` 中，根据选取驱动表的不同，外连接仍然可以细分为2中：

  * 左外连接

    选取左侧的表为驱动表

  * 右外连接

    选取右侧的表为驱动表

`WHERE` 子句和 `ON` 子句中的过滤条件：

* `WHERE` 子句中的过滤条件

  `WHERE` 子句中的过滤条件就是我们平时见的那种，不论是内连接还是外连接，凡是不符合 `WHERE` 子句的过滤条件的记录都不会被加入最后的结果集

* `ON` 子句中的过滤条件

  对于外连接的驱动表的记录来说，如果无法在被驱动表中找到匹配 `ON` 子句中的过滤条件的记录，那么该记录仍然会被加入到结果集中，对应的被驱动表记录的各个字段使用 `NULL` 值填充

  需要注意的是，这个 `ON` 子句是专门为外连接驱动表中的记录在被驱动表找不到匹配记录时应不应该把该记录加入结果集这个场景下提出的，所以如果把 `ON` 子句放到内连接中，`MySQL` 会把它和 `WHERE` 子句一样对待，也就是说：<font color=red>内连接中的WHERE子句和ON子句是等价的</font>

一般情况下，都把只涉及单表的过滤条件放到 `WHERE` 子句中，把涉及两表的过滤条件都放到 `ON` 子句中，一般把放到 `ON` 子句中的过滤条件也称之为 `连接条件`

#### 左（外）连接的语法

```sql
SELECT * FROM t1 LEFT [OUTER] JOIN t2 ON 连接条件 [WHERE 普通过滤条件];
```

需要注意一点：<font color=red>对于左（外）连接和右（外）连接来说，必须使用 `ON` 子句来指出连接条件</font>

#### 右（外）连接的语法

```sql
SELECT * FROM t1 RIGHT [OUTER] JOIN t2 ON 连接条件 [WHERE 普通过滤条件];
```

#### 内连接的语法

内连接和外连接的根本区别就是<font color=red>在驱动表中的记录不符合 `ON` 子句中的连接条件时不会把该记录加入到最后的结果集</font>

内连接的写法有很多：

```sql
SELECT * FROM t1 [INNER | CROSS] JOIN t2 [ON 连接条件] [WHERE 普通过滤条件];
```

建议用 `INNER JOIN` 的形式书写内连接，这里需要注意的时：<font color=red>由于在内连接中ON子句和WHERE子句是等价的，所以内连接中不要求强制写明ON子句</font>

## 连接的原理

### 嵌套循环连接（Nested-Loop Join）

通用的两表连接过程如下图所示：

![img](连接的原理.assets\167e43ab3fa0f107)

- 步骤1：选取驱动表，使用与驱动表相关的过滤条件，选取代价最低的单表访问方法来执行对驱动表的单表查询
- 步骤2：对上一步骤中查询驱动表得到的结果集中每一条记录，都分别到被驱动表中查找匹配的记录

如果有3个表进行连接的话，那么 `步骤2` 中得到的结果集就像是新的驱动表，然后第三个表就成为了被驱动表，重复上边过程，也就是 `步骤2` 中得到的结果集中的每一条记录都需要到 `t3` 表中找一找有没有匹配的记录

这个过程就像是一个嵌套的循环，所以这种<font color=red>驱动表只访问一次，但被驱动表却可能被访问多次，访问次数取决于对驱动表执行单表查询后的结果集中的记录条数</font>的连接方式称之为 <font color=red>`嵌套循环连接` </font>（`Nested-Loop Join`），这是最简单，也是最笨拙的一种连接查询算法

### 使用索引加快连接速度

回顾之前 `t1` 表和 `t2` 表的内连接例子：

```sql
SELECT * FROM t1, t2 WHERE t1.m1 > 1 AND t1.m1 = t2.m2 AND t2.n2 < 'd';
```

我们用的其实是 `嵌套循环连接` 算法执行的连接查询：

![img](连接的原理.assets\167e43ab3a02660b-1578970528742)

查询驱动表 `t1` 后的结果集中有两条记录，`嵌套循环连接` 算法需要对被驱动表查询2次：

- 当 `t1.m1 = 2` 时，去查询一遍 `t2` 表，对 `t2` 表的查询语句相当于：

  ```sql
  SELECT * FROM t2 WHERE t2.m2 = 2 AND t2.n2 < 'd';
  ```

- 当 `t1.m1 = 3` 时，再去查询一遍 `t2` 表，此时对 `t2` 表的查询语句相当于：

  ```sql
  SELECT * FROM t2 WHERE t2.m2 = 3 AND t2.n2 < 'd';
  ```

可以看到，原来的 `t1.m1 = t2.m2` 这个涉及两个表的过滤条件在针对`t2`表做查询时关于 `t1` 表的条件就已经确定了，所以我们只需要单单优化对 `t2` 表的查询了，上述两个对 `t2` 表的查询语句中利用到的列是 `m2` 和 `n2` 列，我们可以：

* 在 `m2` 列上建立索引，因为对 `m2` 列的条件是等值查找，比如 `t2.m2 = 2` 、`t2.m2 = 3` 等，所以可能使用到 `ref` 的访问方法，假设使用 `ref` 的访问方法去执行对 `t2` 表的查询的话，需要回表之后再判断 `t2.n2 < d` 这个条件是否成立

  这里有一个比较特殊的情况，就是假设 `m2` 列是 `t2` 表的主键或者唯一二级索引列，那么使用 `t2.m2 = 常数值` 这样的条件从 `t2` 表中查找记录的过程的代价就是常数级别的。我们知道在单表中使用主键值或者唯一二级索引列的值进行等值查找的方式称之为 `const` ，而 `MySQL` 的设计者把在连接查询中对被驱动表使用主键值或者唯一二级索引列的值进行等值查找的查询执行方式称之为： `eq_ref` 

* 在 `n2` 列上建立索引，涉及到的条件是 `t2.n2 < 'd'` ，可能用到 `range` 的访问方法，假设使用 `range` 的访问方法对 `t2` 表进行查询的话，需要回表之后再判断再 `m2` 列上的条件是否成立

假设 `m2` 和 `n2` 列上都存在索引的话，那么就需要从这两个里边挑一个代价更低的去执行对 `t2` 表的查询。当然，建立了索引不一定使用索引，只有在 `二级索引 + 回表` 的代价比全表扫描的代价更低时才会使用索引

另外，有时候连接查询的查询列表和过滤条件中可能只涉及被驱动表的部分列，而这些列都是某个索引的一部分，这种情况下即使不能使用 `eq_ref`、`ref`、`ref_or_null` 或者 `range` 这些访问方法执行对被驱动表的查询的话，也可以使用索引扫描，也就是 `index` 的访问方法来查询被驱动表。所以我们建议在真实工作中最好不要使用 `*` 作为查询列表，最好把真实用到的列作为查询列表

### 基于块的嵌套循环连接（Block Nested-Loop Join）

扫描一个表的过程其实是先把这个表从磁盘上加载到内存中，然后从内存中比较匹配条件是否满足。由于表中的数据可能有很多，采用 `嵌套循环连接` 算法的两表连接过程中，被驱动表可能会被访问好几次，如果这个被驱动表中的数据特别多而且不能使用索引进行访问，那就相当于要从磁盘上读好几次这个表，这个 `I/O` 代价就非常大了，所以得想办法：<font color=red>尽量减少访问被驱动表的次数</font>

当被驱动表中的数据非常多时，每次访问被驱动表，被驱动表的记录会被加载到内存中，在内存中的每一条记录只会和驱动表结果集的一条记录做匹配，之后就会被从内存中清除掉。然后再从驱动表结果集中拿出另一条记录，再一次把被驱动表的记录加载到内存中一遍，周而复始，驱动表结果集中有多少条记录，就得把被驱动表从磁盘上加载到内存中多少次。所以我们可不可以在把被驱动表的记录加载到内存的时候，一次性和多条驱动表中的记录做匹配，这样就可以大大减少重复从磁盘上加载被驱动表的代价了。所以 `MySQL` 的设计者提出了一个 `join buffer` 的概念，`join buffer `就是执行连接查询前申请的一块固定大小的内存，先把若干条驱动表结果集中的记录装在这个 `join buffer` 中，然后开始扫描被驱动表，每一条被驱动表的记录一次性和 `join buffer` 中的多条驱动表记录做匹配，因为匹配的过程都是在内存中完成的，所以这样可以显著减少被驱动表的 `I/O` 代价。使用 `join buffer` 的过程如下图所示：

![img](连接的原理.assets\167e43ab3e5fa2f6)

最好的情况是 `join buffer` 足够大，能容纳驱动表结果集中的所有记录，这样只需要访问一次被驱动表就可以完成连接操作了。`MySQL` 的设计者把这种加入了 `join buffer` 的嵌套循环连接算法称之为 `基于块的嵌套连接` （Block Nested-Loop Join）算法

这个 `join buffer` 的大小是可以通过启动参数或者系统变量 `join_buffer_size` 进行配置，默认大小为 `262144字节` （也就是 `256KB` ），最小可以设置为 `128字节` 。当然，对于优化被驱动表的查询来说，最好是为被驱动表加上效率高的索引，如果实在不能使用索引，并且自己的机器的内存也比较大可以尝试调大 `join_buffer_size` 的值来对连接查询进行优化

另外需要注意的是，驱动表的记录并不是所有列都会被放到 `join buffer` 中，只有查询列表中的列和过滤条件中的列才会被放到 `join buffer` 中，所以再次提醒我们，最好不要把 `*` 作为查询列表，只需要把我们关心的列放到查询列表就好了，这样还可以在 `join buffer` 中放置更多的记录