## 索引的代价

* 空间上的代价

  每建立一个索引都要为它建立一棵 `B+` 树，每一棵 `B+` 树的每一个节点都是一个数据页，一个也默认会占用 `16KB` 的存储空间

* 时间上的代价

  每次对表中的数据进行增、删、改操作时，都需要去修改各个 `B+` 树索引。

  `B+` 树每层节点都是按照索引列的值从小到大的顺序排序而组成了双向链表。而增、删、改操作可能会对节点和记录的排序造成破坏，所以存储引擎需要额外的时间进行一些记录移位，页面分裂、页面回收啥的操作来维护好节点和记录的排序。如果建立了许多索引，每个索引对应的 `B+` 树都要进行相关的维护操作

  <font color=red>**一个表上索引建的越多，就会占用越多的存储空间，在增删改记录的时候性能就越差**</font>

## B+ 树索引适用的条件

假设设立两个索引

* 主键 `id` 列，它存储一个自动递增的整数。所以 `InnoDB` 存储引擎会自动为 `id` 列建立聚簇索引
* 我们额外定义了一个二级索引 `idx_name_birthday_phone_number` ，它是由3个列组成的联合索引。所以在这个索引对应的 `B+` 树的叶子节点处存储的用户记录只保留 `name` 、`birthday `、`phone_number `这三个列的值以及主键 `id` 的值，并不会保存 `country `列的值

### 全值匹配

搜索条件中的列和索引列一致的话，称为全值匹配

```sql
SELECT * FROM person_info WHERE name = 'Ashburn' AND birthday = '1990-09-27' AND phone_number = '15123983239';
```

查询过程：

* 因为 `B+` 树的数据页和记录先是按照 `name` 列的值进行排序的，所以先可以很快定位 `name` 列的值是 `Ashburn` 的记录位置
* 在 `name` 列相同的记录里又是按照 `birthday` 列的值进行排序的，所以在 `name` 列的值是 `Ashburn` 的记录里又可以快速定位 `birthday` 列的值是 `1990-09-27` 的记录
* 如果很不幸， `name` 和 `birthday` 列的值都是相同的，那记录是按照 `phone_number` 列的值排序的，所以联合索引中的三个列都可能被用到

当 `WHERE` 子句中的几个搜索条件的顺序发生调换时，对结果会有影响嘛？比如说

```sql
SELECT * FROM person_info WHERE birthday = '1990-09-27' AND phone_number = '15123983239' AND name = 'Ashburn';
```

是没影响的， `MySQL` 有**查询优化器**会分析搜索条件并且按照可以使用的索引中列的顺序来决定先使用哪个搜索条件，后使用哪个搜索条件

### 匹配左边的列

单个列：

```sql
SELECT * FROM person_info WHERE name = 'Ashburn';
```

多个列：

```sql
SELECT * FROM person_info WHERE name = 'Ashburn' AND birthday = '1990-09-27';
```

在搜索中可以不用包含全部联合索引中的列，只包含左边的就行，但是下面这个就**用不到** `B+` 树索引

```sql
SELECT * FROM person_info WHERE birthday = '1990-09-27';
```

因为 `B+` 树的数据页和记录先是按照 `name` 列的值排序的，在 `name` 列的值相同的情况下才使用 `birthday `列进行排序，也就是说 `name` 列的值不同的记录中 `birthday` 的值可能是无序的。而现在你跳过 `name` 列直接根据 `birthday` 的值去查找，就不行了，那如果我就想在只使用 `birthday` 的值去通过`B+`树索引进行查找咋办呢？这好办，你再对 `birthday `列建一个 `B+ `树索引就行了

但要特别注意一点：<font color=red>**如果我们想使用联合索引中尽可能多的列，搜索条件中的各个列必须是联合索引中从最左边连续的列**</font>

### 匹配列前缀

建立索引实际上会在对应的 `B+` 树记录中使用该列的值进行排序

排好序的字符串列有如下的特点：

* 先按照字符串的第一个字符进行排序
* 如果第一个字符相同再按照第二个字符进行排序
* 如果第二个字符相同再按照第三个字符进行排序，以此类推

所以说，这些字符串中的前n个字符，也就是前缀都是排好序的，所以对于字符串类型的索引列来说，我们只匹配它的前缀也是可以快速定位记录的，比如说：

```sql
SELECT * FROM person_info WHERE name LIKE 'As%';
```

但需要注意的是，如果只给出后缀或者中间某个字符串，比如：`'%As%'` ，那么 `MySQL` 就无法快速定位记录位置了，因为字符串中间有 `'As'` 的字符串并没有排好序，，所以只能全表扫描了。

假设已经对该 `url `列创建了索引，当有时候需要查询以 `com` 为后缀的网址的话可以把 `url` 列的值倒序存储，然后利用索引查询 `com*` 就可以

### 匹配范围值

索引中，因为<font color=red>**所有记录都是按照索引列的值从小到大的顺序排好序的**</font>，所以这极大的方便了查找索引列的值再某个范围内的记录，比如说：

```sql
SELECT * FROM person_info WHERE name > 'Asa' AND name < 'Barlow';
```

由于 `B+` 树中的数据页和记录是先按 `name` 列排序的，所以查询过程为：

- 找到 `name` 值为 `Asa` 的记录
- 找到 `name` 值为 `Barlow` 的记录
- 由于所有记录都是由链表连起来的（记录之间用单链表，数据页之间用双链表），所以他们之间的记录都可以很容易的取出来
- 找到这些记录的主键值，再到 <font color=red>`聚簇索引`</font> 中 <font color=red>`回表`</font> 查找完整的记录

不过再使用联合进行范围查找的时候需要注意：<font color=red>**如果对多个列同时进行范围查找的话，只有对索引最左边的那个列进行范围查找的时候才能用到 `B+` 树索引**</font>，比如说：

```sql
SELECT * FROM person_info WHERE name > 'Asa' AND name < 'Barlow' AND birthday > '1980-01-01';
```

### 精准匹配某一列并范围匹配另外一列

对于同一个联合索引来说，虽然对多个列都进行范围查找时只能用到最左边那个索引列，但是如果左边的列是精确查找，则右边的列可以进行范围查找，比方说：

```sql
SELECT * FROM person_info WHERE name = 'Ashburn' AND birthday > '1980-01-01' AND birthday < '2000-12-31' AND phone_number > '15100000000';
```

同理，下边的查询也是可能用到这个 `idx_name_birthday_phone_number` 联合索引的：

```sql
SELECT * FROM person_info WHERE name = 'Ashburn' AND birthday = '1980-01-01' AND phone_number > '15100000000';
```

### 用于排序

```sql
SELECT * FROM person_info ORDER BY name, birthday, phone_number LIMIT 10;
```

由于之前已经建立了 `idx_name_birthday_phone_number` 索引，该索引本身就是按照上述规则排好的，所以可以直接从索引中提取数据，然后 <font color=red>`回表`</font> 操作取出该索引中不包含的列就行了

#### 使用联合索引进行排序注意事项

对于 `联合索引` 有个问题需要注意，`ORDER BY` 的子句后边的列的顺序也必须按照索引列的顺序给出，如果给出 `ORDER BY phone_number, birthday, name` 的顺序，那也是用不了 `B+` 树索引

当联合索引左边列的值为常量时，也可以使用后边的列进行排序，比如：

```sql
SELECT * FROM person_info WHERE name = 'A' ORDER BY birthday, phone_number LIMIT 10;
```

#### 不可以使用索引进行排序的几种情况

**ASC、DESC 混用**

对于使用联合索引进行排序的场景，我们要求各个排序列的排序顺序是一致的，也就是要么各个列都是 `ASC `规则排序，要么都是 `DESC` 规则排序

>ORDER BY子句后的列如果不加 ASC 或者 DESC 默认是按照 ASC 排序规则排序的，也就是升序排序的。

**WHERE 子句中出现非排序使用到的索引列**

如果WHERE子句中出现了非排序使用到的索引列，那么排序依然是使用不到索引的，比方说：

```sql
SELECT * FROM person_info WHERE country = 'China' ORDER BY name LIMIT 10;
```

其中 `country` 列是没有建立索引的

**排序列包含非同一个索引的列**

有时候用来排序的多个列不是一个索引里的，这种情况也不能使用索引进行排序，比方说：

```sql
SELECT * FROM person_info ORDER BY name, country LIMIT 10;
```

`name `和 `country` 并不属于一个联合索引中的列，所以无法使用索引进行排序

**排序列使用了复杂的表达式**

要想使用索引进行排序操作，必须保证索引列是以单独列的形式出现，而不是修饰过的形式，比方说：

```sql
SELECT * FROM person_info ORDER BY UPPER(name) LIMIT 10;
```

### 用于分组

```sql
SELECT name, birthday, phone_number, COUNT(*) FROM person_info GROUP BY name, birthday, phone_number
```

因为分组的顺序与之前建立的 `B+` 树索引列的顺序一致，所以可以直接使用索引进行分组

## 回表的代价

对于下边这个查询：

```sql
SELECT * FROM person_info WHERE name > 'Asa' AND name < 'Barlow';
```

在使用`idx_name_birthday_phone_number` 索引进行查询时的步骤为：

1. 从索引 `idx_name_birthday_phone_number` 对应的 `B+` 树中取出 `name` 值在 `Asa`～`Barlow ` 之间的用户记录
2. 由于索引 `idx_name_birthday_phone_number` 对应的 `B+` 树用户记录中只包含 `name`、`birthday`、`phone_number`、`id` 这4个字段，而查询列表是 `*` ，意味着要查询表中所有字段，也就是还要包括 `country` 字段。这时需要把从上一步中获取到的每一条记录的 `id` 字段都到聚簇索引对应的 `B+` 树中找到完整的用户记录，也就是我们通常所说的 <font color=red>`回表`</font> ，然后把完整的用户记录返回给查询用户

由于索引 `idx_name_birthday_phone_number` 对应的 `B+` 树中的记录首先会按照 `name` 列的值进行排序，所以值在 `Asa`～`Barlow `之间的记录在磁盘中的存储是相连的，集中分布在一个或几个数据页中，我们可以很快的把这些连着的记录从磁盘中读出来，这种读取方式我们也可以称为 `顺序I/O` 。根据第1步中获取到的记录的 `id` 字段的值可能并不相连，而在聚簇索引中记录是根据 `id`（也就是主键）的顺序排列的，所以根据这些并不连续的 `id` 值到聚簇索引中访问完整的用户记录可能分布在不同的数据页中，这样读取完整的用户记录可能要访问更多的数据页，这种读取方式我们也可以称为 `随机I/O` 。一般情况下，顺序I/O比随机I/O的性能高很多，所以步骤1的执行可能很快，而步骤2就慢一些。所以这个使用索引 `idx_name_birthday_phone_number` 的查询有这么两个特点：

- 会使用到两个 `B+` 树索引，一个二级索引，一个聚簇索引
- 访问二级索引使用 `顺序I/O` ，访问聚簇索引使用 `随机I/O`

<font color=red>**需要回表的记录越多，使用二级索引的性能就越低**</font>，甚至让某些查询宁愿使用全表扫描也不使用 `二级索引` 。比方说 `name` 值在 `Asa`～`Barlow` 之间的用户记录数量占全部记录数量90%以上，那么如果使用 `idx_name_birthday_phone_number` 索引的话，有90%多的 `id` 值需要回表，这不是吃力不讨好么，还不如直接去扫描聚簇索引（也就是全表扫描）

那什么时候采用全表扫描的方式，什么时候使用采用 `二级索引 + 回表` 的方式去执行查询呢？这个就是传说中的查询优化器做的工作，查询优化器会事先对表中的记录计算一些统计数据，然后再利用这些统计数据根据查询的条件来计算一下需要回表的记录数，需要回表的记录数越多，就越倾向于使用全表扫描，反之倾向于使用 `二级索引 + 回表` 的方式。当然优化器做的分析工作不仅仅是这么简单，但是大致上是个这个过程。一般情况下，限制查询获取较少的记录数会让优化器更倾向于选择使用 `二级索引 + 回表` 的方式进行查询，因为回表的记录越少，性能提升就越高，比方说上边的查询可以改写成这样：

```sql
SELECT * FROM person_info WHERE name > 'Asa' AND name < 'Barlow' LIMIT 10;
```

添加了 `LIMIT 10` 的查询更容易让优化器采用 `二级索引 + 回表` 的方式进行查询

对于有排序需求的查询，上边讨论的采用 `全表扫描` 还是 `二级索引 + 回表` 的方式进行查询的条件也是成立的，比方说下边这个查询：

```sql
SELECT * FROM person_info ORDER BY name, birthday, phone_number;
```

由于查询列表是 `*` ，所以如果使用二级索引进行排序的话，需要把排序完的二级索引记录全部进行回表操作，这样操作的成本还不如直接遍历聚簇索引然后再进行文件排序（`filesort`）低，所以优化器会倾向于使用`全表扫描`的方式执行查询。如果我们加了 `LIMIT `子句，比如这样：

```sql
SELECT * FROM person_info ORDER BY name, birthday, phone_number LIMIT 10;
```

这样需要回表的记录特别少，优化器就会倾向于使用 `二级索引 + 回表` 的方式执行查询

### 覆盖索引

为了彻底告别 `回表` 操作带来的性能损耗，建议：<font color=red>最好在查询列表里只包含索引列</font>，比如：

```sql
SELECT name, birthday, phone_number FROM person_info WHERE name > 'Asa' AND name < 'Barlow'
```

## 如何挑选索引

### 只为用于搜索、排序和分组的列创建索引

也就是说，只为出现在 `WHERE` 子句中的列、连接子句中的连接列，或者出现在 `ORDER BY` 或 `GROUP BY` 子句中的列创建索引

### 考虑列的基数

`列的基数` 指的是某一列中不重复数据的个数，比方说某个列包含值 `2, 5, 8, 2, 5, 8, 2, 5, 8` ，虽然有 `9` 条记录，但该列的基数却是 `3` 。也就是说，<font color=red>在记录行数一定的情况下，列的基数越大，该列中的值越分散，列的基数越小，该列中的值越集中</font>

<font color=red>最好为那些列的基数大的列建立索引，为基数太小列的建立索引效果可能不好</font>

### 索引列的类型尽量小

类型大小指的是<font color=red>该类型表示的数据范围的大小</font>，如果我们想要对某个整数列建立索引的话，<font color=red>在表示的整数范围允许的情况下，尽量让索引列使用较小的类型</font>，这是因为：

- 数据类型越小，在查询时进行的比较操作越快（这是CPU层次的东东）
- 数据类型越小，索引占用的存储空间就越少，在一个数据页内就可以放下更多的记录，从而减少磁盘 `I/O` 带来的性能损耗，也就意味着可以把更多的数据页缓存在内存中，从而加快读写效率

这个建议对于表的主键来说更加适用，因为不仅是聚簇索引中会存储主键值，其他所有的二级索引的节点处都会存储一份记录的主键值，如果主键适用更小的数据类型，也就意味着节省更多的存储空间和更高效的 `I/O`

### 索引字符串值的前缀

我们知道一个字符串其实是由若干个字符组成，如果我们在 `MySQL` 中使用 `utf8` 字符集去存储字符串的话，编码一个字符需要占用 `1~3` 个字节。假设我们的字符串很长，那存储一个字符串就需要占用很大的存储空间。在我们需要为这个字符串列建立索引时，那就意味着在对应的 `B+` 树中有这么两个问题：

- `B+ `树索引中的记录需要把该列的完整字符串存储起来，而且字符串越长，在索引中占用的存储空间越大。
- 如果 `B+ `树索引中索引列存储的字符串很长，那在做字符串比较时会占用更多的时间。

我们前边儿说过索引列的字符串前缀其实也是排好序的，所以索引的设计者提出了个方案 --- <font color=red>只对字符串的前几个字符进行索引</font>也就是说在二级索引的记录中只保留字符串前几个字符。这样在查找记录时虽然不能精确的定位到记录的位置，但是能定位到相应前缀所在的位置，然后根据前缀相同的记录的主键值回表查询完整的字符串值，再对比就好了。这样只在 `B+` 树中存储字符串的前几个字符的编码，既节约空间，又减少了字符串的比较时间，还大概能解决排序的问题，何乐而不为，比方说我们在建表语句中只对 `name` 列的前10个字符进行索引可以这么写：

```sql
CREATE TABLE person_info(
    name VARCHAR(100) NOT NULL,
    birthday DATE NOT NULL,
    phone_number CHAR(11) NOT NULL,
    country varchar(100) NOT NULL,
    KEY idx_name_birthday_phone_number (name(10), birthday, phone_number)
);    
```

`name(10)` 就表示在建立的`B+`树索引中只保留记录的前 `10` 个字符的编码，这种<font color=red>只索引字符串值的前缀的策略是我们非常鼓励的，尤其是在字符串类型能存储的字符比较多的时候</font>

#### 索引列前缀对排序的影响

如果使用了索引列前缀，比方说之前只把 `name` 列的前10个字符放到了二级索引中，下边这个查询会有点问题：

```sql
SELECT * FROM person_info ORDER BY name LIMIT 10;
```

因为二级索引中不包含完整的 `name` 列信息，所以无法对前十个字符相同，后边的字符不同的记录进行排序，也就是使用索引列前缀的方式无法支持使用索引排序，只能用文件排序

### 让索引列再比较表达式中单独出现

假设表中有一个整数列 `my_col` ，我们为这个列建立了索引。下边的两个 `WHERE` 子句虽然语义是一致的，但是在效率上却有差别：

1. `WHERE my_col * 2 < 4`
2. `WHERE my_col < 4/2`

第1个 `WHERE` 子句中 `my_col` 列并不是以单独列的形式出现的，而是以 `my_col * 2` 这样的表达式的形式出现的，存储引擎会依次遍历所有的记录，计算这个表达式的值是不是小于 `4` ，所以这种情况下是使用不到为 `my_col` 列建立的 `B+` 树索引的。而第2个 `WHERE` 子句中 `my_col` 列并是以单独列的形式出现的，这样的情况可以直接使用 `B+` 树索引。

所以结论就是：<font color=red>如果索引列在比较表达式中不是以单独列的形式出现，而是以某个表达式，或者函数调用形式出现的话，是用不到索引的</font>

### 主键插入顺序

对于 `InnoDB` 存储引擎的表来说，没有显式的创建索引时，表中的数据实际上都是存储再 `聚簇索引` 的叶子节点的，而记录又是存储再数据页中的，数据页和记录又是按照记录主键值从小到大的顺序进行排序（假设为 `1~100`）。所以当建立好一个按主键排序的顺序表后，插入一条主键在前面的数据（比如说 `9`）就会发生数据页分裂、移动，造成性能损耗。所以建议：<font color=red>让主键具有`AUTO_INCREMENT`，让存储引擎自己为表生成主键，而不是我们手动插入</font>

## 总结

* `B+ `树索引在空间和时间上都有代价，所以没事儿别瞎建索引
* `B+`树索引适用于下边这些情况：
  - 全值匹配
  - 匹配左边的列
  - 匹配范围值
  - 精确匹配某一列并范围匹配另外一列
  - 用于排序
  - 用于分组
* 在使用索引时需要注意下边这些事项：
  - 只为用于搜索、排序或分组的列创建索引
  - 为列的基数大的列创建索引
  - 索引列的类型尽量小
  - 可以只对字符串值的前缀建立索引
  - 只有索引列在比较表达式中单独出现才可以适用索引
  - 为了尽可能少的让 `聚簇索引` 发生页面分裂和记录移位的情况，建议让主键拥有` AUTO_INCREMENT` 属性。
  - 定位并删除表中的重复和冗余索引
  - 尽量使用 `覆盖索引` 进行查询，避免`回表`带来的性能损耗