# 单表访问方法

首先，先建立一个表来对执行方法进行说明：

```sql
CREATE TABLE single_table (
    id INT NOT NULL AUTO_INCREMENT,
    key1 VARCHAR(100),
    key2 INT,
    key3 VARCHAR(100),
    key_part1 VARCHAR(100),
    key_part2 VARCHAR(100),
    key_part3 VARCHAR(100),
    common_field VARCHAR(100),
    PRIMARY KEY (id),
    KEY idx_key1 (key1),
    UNIQUE KEY idx_key2 (key2),
    KEY idx_key3 (key3),
    KEY idx_key_part(key_part1, key_part2, key_part3)
) Engine=InnoDB CHARSET=utf8;
```

我们为这个 `single_table` 表建立了1个聚簇索引和4个二级索引，分别是：

- 为 `id` 列建立的聚簇索引。
- 为 `key1` 列建立的`idx_key1`二级索引。
- 为 `key2` 列建立的`idx_key2`二级索引，而且该索引是唯一二级索引。
- 为 `key3` 列建立的`idx_key3`二级索引。
- 为 `key_part1`、`key_part2`、`key_part3 `列建立的 `idx_key_part` 二级索引，这也是一个联合索引。

## 访问方法的概念

对于单个表的查询来说，`MySQL` 查询的执行方法大致分为下边两种：

* 使用全表扫描

  把表中的每一行记录都扫一遍，把符合搜索条件的记录加入到结果集中

* 使用索引进行查询

  使用索引查询的方式又可以细分为：

  * 针对主键或唯一二级索引的等值查询
  * 针对普通二级索引的等值查询
  * 针对索引列的范围查询
  * 直接扫描整个索引

这些 `MySQL` 执行查询语句的方式被称之为 `访问方法` 或者 `访问类型` 

下面介绍一下各种 `访问方法` 的具体内容

## const

我们可以通过主键列来定位一条记录，比如说：

```sql
SELECT * FROM single_table WHERE id = 1438;
```

`MySQL` 会直接利用主键值在聚簇索引中定位对应的用户记录

类似的，根据唯一二级索引列来定位一条记录的速度也是很快的，比如说：

```sql
SELECT * FROM single_table WHERE key2 = 3841;
```

这个查询的执行过程的示意图为：

![img](单表访问方法.assets\16a7b843e05c8e33)

设计 `MySQL` 的人认为通过主键或者唯一二级索引列于常数的等值比较来定位一条记录是非常快的，所以他们把这种通过主键或者唯一二级索引列来定位一条记录的访问方法定义为：`const` ，意思是常数级别的，代价是可以忽略不计的

不过这种 `const` 访问方法只能在主键列或者唯一二级索引列和一个常数进行等值比较时才有效，如果主键或者唯一二级索引是由多个列构成的话，索引中的每一个列都需要与常数进行等值比较，这个 `const` 访问方法才有效（这是因为只有该索引中全部列都采用等值比较才可以定位唯一的一条记录）

对于唯一二级索引来说，查询该列为 `NULL` 值的情况比较特殊，比如说：

```sql
SELECT * FROM single_table WHERE key2 IS NULL;
```

因为唯一二级索引列并不限制 NULL 值的数量，所以上述语句可能访问到多条记录，也就是说上边这个语句不可以使用 `const` 访问方法来执行

## ref

我们对某个普通的二级索引列与常数进行等值比较，比如说：

```sql
SELECT * FROM single_table WHERE key1 = 'abc';
```

由于普通二级索引并不限制索引列值的唯一性，所以可能找到多条对应的记录，也就是说使用二级索引来执行查询的代价取决于等值匹配到的二级索引记录条数。如果匹配的记录较少，则回表的代价还是比较低的，所以 `MySQL` 可能选择使用索引而不是全表扫描的方式来执行查询。 `MySQL` 的设计者就把这种搜索条件为二级索引列与常数等值比较，采用二级索引来执行查询的访问方法称为： `ref`

下面是采用 `ref` 访问方法执行查询的图示：

![img](单表访问方法.assets\16a7b843e5e227f1)

这种 `ref` 访问方法比 `const` 差了一些，但是在二级索引等值比较时匹配的记录数较少时的效率还是很高的（如果匹配的二级索引记录太多那么回表的成本就太大了）。但需要注意下边两种情况：

* 二级索引列值为 `NULL` 的情况

  不论时普通的二级索引，还是唯一二级索引，它们的索引列对包含 `NULL` 值的数量并不限制，所以我i们采用 `key IS NULL` 这种形式的搜索条件最多只能使用 `ref` 的访问方法，而不是 `const` 的访问方法

* 对于某个包含多个索引列的二级索引来说，只要是最左边的连续索引列是与常数的等值比较就可能采用 `ref` 的访问方法，比方说下边这几个查询：

  ```sql
  SELECT * FROM single_table WHERE key_part1 = 'god like';
  
  SELECT * FROM single_table WHERE key_part1 = 'god like' AND key_part2 = 'legendary';
  
  SELECT * FROM single_table WHERE key_part1 = 'god like' AND key_part2 = 'legendary' AND key_part3 = 'penta kill';
  ```

  但是如果最左边的连续索引列并不全部都是等值比较的话，他的访问方法就不能称为 `ref` 了，比如说：

  ```sql
  SELECT * FROM single_table WHERE key_part1 = 'god like' AND key_part2 > 'legendary';
  ```

## ref_or_null

有时候不仅想找出某个二级索引列的值等于某个常数的记录，还想把该列的值为 `NULL` 的记录也找出来，就像下边这个查询：

```sql
SELECT * FROM single_table WHERE key1 = 'abc' OR key1 IS NULL;
```

当使用二级索引而不是全表扫描的方式执行该查询时，这种类型的查询使用的访问方法就称为：`ref_or_null` ，这个 `ref_or_null` 访问方法的执行过程如下：

![img](单表访问方法.assets\16a7b843e8927bee)

## range

之前几种访问方法都是在对索引列与某一个常数进行等值比较的时候才可能使用到，但是有时候面对的搜索条件更复杂，比如说：

```sql
SELECT * FROM single_table WHERE key2 IN (1438, 6328) OR (key2 >= 38 AND key2 <= 79);
```

可以使用 `二级索引 + 回表` 的方式执行，在本查询中 `key2` 列的值只要匹配下列3个范围中的任何一个就算是匹配成功了：

* `key` 的值是 `1438`
* `key` 的值是 `6382`
* `key` 的值在 `38` 和 `79` 之间

`MySQL` 的设计者把这种利用索引进行范围匹配的访问方法称之为： `range`

## index

```sql
SELECT key_part1, key_part2, key_part3 FROM single_table WHERE key_part2 = 'abc';
```

上面这个查询中，由于 `key_ppart2` 并不是联合索引 `idx_key_part` 最左索引列，所以无法使用 `ref` 或者 `range` 访问方法来执行这个语句

但是这个查询符合下边这两个条件：

* 它的查询列表只有3个列：`key_part1` 、`key_part2` 、`key_part3` ，而索引 `idx_key_part` 又包含这三个列
* 搜索条件中只有 `key_part2` 列，这个列也包含在索引 `idx_key_part` 中

也就是说我们可以直接通过遍历 `idx_key_part` 索引的叶子节点的记录来比较 `key_part2 = 'abc'` 这个条件是否成立，把匹配成功的二级索引记录的 `key_part1`, `key_part2`, `key_part3 `列的值直接加到结果集中就行了。由于二级索引记录比聚簇索记录小的多（聚簇索引记录要存储所有用户定义的列以及所谓的隐藏列，而二级索引记录只需要存放索引列和主键），而且这个过程也不用进行回表操作，所以直接遍历二级索引比直接遍历聚簇索引的成本要小很多，`MySQL` 的设计者就把这种采用遍历二级索引记录的执行方式称之为：`index`

## all

最直接的查询执行方式就是我们已经提了无数遍的全表扫描，对于`InnoDB`表来说也就是直接扫描聚簇索引，`MySQL` 的设计者把这种使用全表扫描执行查询的方式称之为：`all`

## 注意事项

### 重温 二级索引 + 回表

<font color=red>一般情况</font>下只能利用单个二级索引执行查询，比方说下边的这个查询：

```sql
SELECT * FROM single_table WHERE key1 = 'abc' AND key2 > 1000;
```

查询优化器会识别这个查询中的两个搜索条件：

* `key1 = 'abc'`
* `key2 > 1000`

优化器一般会根据 `single_table` 表的统计数据来判断到底使用哪个条件到对应的二级索引中查询扫描的行数会更少，选择那个扫描行数少的条件到对应的二级索引中查询。然后将从该二级索引中查询到的结果经过回表得到完整的用户记录后再根据其余的 `WHERE` 条件过滤记录。一般来说，等值查找比范围查找需要扫描的行数更少（也就是 `ref` 的访问方法一般比 `range` 好，但这也不总是一定的，也可能采用 `ref` 访问方法的那个索引列的值为特定值的行数特别多），所以这里假设优化器决定使用 `idx_key1` 索引进行查询，那么整个查询过程可以分为两个步骤：

- 步骤1：使用二级索引定位记录的阶段，也就是根据条件 `key1 = 'abc'` 从 `idx_key1` 索引代表的 `B+` 树中找到对应的二级索引记录
- 步骤2：回表阶段，也就是根据上一步骤中找到的记录的主键值进行`回表`操作，也就是到聚簇索引中找到对应的完整的用户记录，再根据条件 `key2 > 1000` 到完整的用户记录继续过滤。将最终符合过滤条件的记录返回给用户

这里需要特别提醒一点：<font color=red>因为二级索引的节点中只包含索引列和主键，所以再步骤1中使用 `idx_key1` 索引进行查询时只会用到与 `key1` 列有关的搜索条件，其余条件，比如 `key2 > 1000` 这个条件再步骤1中是用不到的，只有再步骤2完成回表操作后才能继续针对完整的用户记录中继续过滤</font>

### 明确 range 访问方法使用的范围区间

其实对于 `B+` 树索引来说，只要索引列和常数使用 `=` 、`<=>` 、`IN` 、`NOT IN` 、`IS NULL` 、`IN NOT NULL` 、`>` 、 `<` 、 `>=` 、 `<=` 、 `BETWEEN` 、 `!=` （不等于也可以写成 `<>`）或者 `LIKE` 操作符连接起来，就可以产生一个所谓的 `区间`

注意：LIKE操作符比较特殊，只有在匹配完整字符串或者匹配字符串前缀时才可以利用索引。N操作符的效果和若干个等值匹配操作符 `=` 之间用 `OR` 连接起来是一样的，也就是说会产生多个单点区间

当我们想使用 `range` 访问方法来执行一个查询语句时，重点就是找出该查询可用的索引以及这些索引对应的范围区间。下边分两种情况看一下怎么从由 `AND` 或 `OR` 组成的复杂搜索条件中提取出正确的范围区间

#### 所有搜索条件都可以使用某个索引的情况

有时候每个搜索条件都可以使用到某个索引，比如说：

```sql
SELECT * FROM single_table WHERE key2 > 100 AND key2 > 200;
```

![img](单表访问方法.assets\16a7b843e0fb74ac)

下边是使用 `OR` 将多个搜索条件连接在一起的情况：

```sql
SELECT * FROM single_table WHERE key2 > 100 OR key2 > 200;
```

![img](单表访问方法.assets\16a7b8448ea4909c)

#### 有的搜索条件无法使用索引的情况

比如说：

```sql
SELECT * FROM single_table WHERE key2 > 100 AND common_field = 'abc';
```

这个查询语句中能利用的索引只有 `idx_key2` 一个，而 `idx_key2` 这个二级索引的记录中又不包含 `common_field` 这个字段，所以在使用二级索引 `idx_key2` 定位记录的阶段用不到 `common_field = 'abc'` 这个条件，这个条件是在回表获取了完整的用户记录后才使用的，而`范围区间`是为了到索引中取记录中提出的概念，所以在确定 `范围区间` 的时候不需要考虑 `common_field = 'abc'` 这个条件，我们在为某个索引确定范围区间的时候只需要把用不到相关索引的搜索条件替换为 `TRUE` 就好了

之所以把用不到索引的搜索条件替换为TRUE，是因为我们不打算使用这些条件进行在该索引上进行过滤，所以不管索引的记录满不满足这些条件，我们都把它们选取出来，待到之后回表的时候再使用它们过滤

接下来是使用 `OR` 的情况：

```sql
SELECT * FROM single_table WHERE key2 > 100 OR common_field = 'abc';
```

同理，我们把使用不到 `idx_key2` 索引的搜索条件替换为 `TRUE` ：

```sql
SELECT * FROM single_table WHERE key2 > 100 OR TRUE;
```

化简为：

```sql
SELECT * FROM single_table WHERE TRUE;
```

这说明如果我们强制使用 `idx_key2` 执行查询的话，需要将全部二级索引的记录进行回表，这个代价比直接全表扫描都大。也就是说一个所用到索引的搜索条件和没有使用到该搜索条件使用 `OR` 连接起来后是无法使用该索引的

#### 复杂搜索条件下找出范围匹配的区间

有的查询的搜索条件可能特别复杂，比如说：

```sql
SELECT * FROM single_table WHERE 
        (key1 > 'xyz' AND key2 = 748 ) OR
        (key1 < 'abc' AND key1 > 'lmn') OR
        (key1 LIKE '%suf' AND key1 > 'zzz' AND (key2 < 8000 OR common_field = 'abc')) ;
```

分析执行流程：

* 首先查看 `WHERE` 子句中的搜索条件都涉及到了哪些列，哪些列可能使用到索引

  这个查询的搜索条件涉及到了 `key1` 、`key2` 、`common_field` 这3个列，然后 `key1` 列有普通的二级索引 `idx_key1` ，`key2` 列有唯一二级索引 `idx_key2`

* 对于那些可能用到的索引，分析它们的范围区间

  * 假设我们使用 `idx_key1` 执行查询

    * 我们需要把那些用不到该索引的搜索条件暂时移除掉，移除方法也简单，直接把它们替换为 `TRUE` 就好了。上边的查询中除了有关 `key2` 和 `common_field` 列不能使用到 `idx_key1` 索引外，`key1 LIKE '%suf'` 也使用不到索引，所以把这些搜索条件替换为 `TRUE` 之后，再进行化简的样子就是这样：

      ```SQL
      (key1 > 'xyz') OR
      (key1 < 'abc' AND key1 > 'lmn') OR
      (key1 > 'zzz')
      ```

    * 因为符合 `key1 < 'abc' AND key1 > 'lmn'` 永远为 `FALSE` ，所以上边的搜索条件可以被写成这样：

      ```sql
      (key1 > 'xyz') OR (key1 > 'zzz')
      ```

    * 继续化简区间

      `key1 > 'xyz'`和`key1 > 'zzz' `之间使用 `OR` 操作符连接起来的，意味着要取并集，所以最终的结果化简的到的区间就是： `key1 > xyz` 。也就是说：<font color=red>上边那个有一坨搜索条件的查询语句如果使用 `idx_key1` 索引执行查询的话，需要把满足 `key1 > xyz` 的二级索引记录都取出来，然后拿着这些记录的id再进行回表，得到完整的用户记录之后再使用其他的搜索条件进行过滤</font>

  * 假设使用 `idx_key2` 执行查询

    * 我们需要把那些用不到该索引的搜索条件暂时使用`TRUE`条件替换掉，其中有关`key1`和`common_field`的搜索条件都需要被替换掉，替换结果就是：

      ```sql
      (TRUE AND key2 = 748 ) OR
      (TRUE AND TRUE) OR
      (TRUE AND TRUE AND (key2 < 8000 OR TRUE))
      ```

      化简为：

      ```sql
      key2 = 748 OR TRUE
      ```

      结果是 `TRUE` ，这个结果也就意味着如果我们要使用 `idx_key2` 索引执行查询语句的话，需要扫描 `idx_key2` 二级索引的所有记录，然后再回表，这不是得不偿失么，所以这种情况下不会使用 `idx_key2` 索引的

### 索引合并

之前说过 `MySQL` 在一般情况下执行一个查询时最多只会用到单个二级索引，但还是有特殊情况的，在特殊情况下也可能在一个查询中使用到多个二级索引，`MySQL` 的设计者把这种使用到多个索引来完成一次查询的执行方法称之为： `index merge` ，具体的索引合并算法有下边三种：

#### Intersection 合并

`Intersection ` 翻译过来的意思是 `交集` 。这里是说某个查询可以使用多个二级索引，将从多个二级索引中查询到的结果取交集，比如说：

```sql
SELECT * FROM single_table WHERE key1 = 'a' AND key3 = 'b';
```

假设这个查询使用 `Intersection` 合并的方式执行的话，那这个过程就是这样的：

* 从 `idx_key1` 二级索引对应的 `B+` 树中取出 `key1 = 'a'` 的相关记录
* 从 `idx_key3` 二级索引对应的 `B+` 树中取出 `key3 = 'b'` 的相关记录
* 二级索引的记录都是由 `索引列 + 主键` 构成的，所以我们可以计算出这两个结果集中 `id` 值的交集
* 按照上一步生成的 `id` 值列表进行回表操作，也就是从聚簇索引中把指定 `id` 值的完整用户记录取出来，返回给用户

这里可以同时分析下直接使用 `idx_key1` 或者 `idx_key3` 只根据某个搜索条件去读取一个二级索引，然后回表后再过滤另外一个搜索条件的成本代价和使用两个二级索引的成本代价：

**只读取一个二级索引的成本：**

* 按照某个搜索条件读取一个二级索引
* 根据从该二级索引得到的主键值进行回表操作，然后再过滤其他的搜索条件

**读取多个二级索引之后取交集成本：**

* 按照不同的搜索条件分别读取不同的二级索引
* 将从多个二级索引得到的主键值取交集，然后进行回表操作

虽然读取多个二级索引比读取一个二级索引消耗性能，但是读取二级索引的操作是 `顺序I/O` ，而回表操作是 `随机I/O` ，所以如果只读取一个二级索引时需要回表的记录数特别多，而读取多个二级索引之后取交集的记录数非常少，当节省的因为 `回表` 而造成的性能损耗比访问多个二级索引带来的性能损耗更高时，读取多个二级索引后取交集比只读取一个二级索引的成本更低

`MySQL` 在某些特定的情况下才可能会使用到 `Intersection` 索引合并：

* 情况一：二级索引是等值匹配的情况，对于联合索引来说，在联合索引中的每个列都必须等值匹配，不能出现只匹配部分列的情况

* 情况二：主键列可以是范围匹配

  比如说，下面这个查询可能用到主键和 `idx_key1` 进行 `Intersection` 索引合并的操作：

  ```sql
  SELECT * FROM single_table WHERE id > 100 AND key1 = 'a';
  ```



