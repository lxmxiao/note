## 谈谈你对 JVM JDK 和 JRE 的理解(JDK 和 JRE的区别是什么?)。什么是字节码?为什么要采用字节码?

#### JVM

Java 虚拟机是运行Java字节码文件的虚拟机，JVM可以在不同的系统上运行，字节码和不同系统的JVM是实现“一次编译，处处运行”的关键所在，使用相同的字节码，都会得出相同的结果

#### 什么是字节码?采用字节码的好处是什么?

JDK 工具javac （Java编译器），可以把 Java 文件编译为 JVM可以识别的 .class 文件

.class 文件即为字节码文件

Java 语言通过字节码的方式，解决了传统解释型语言执行效率低的问题，同时又保持了解释型语言可移植的特点

#### Java 程序从源代码到运行一般有3步：

1. .java 文件使用 javac 进行编译

   编译过程又可以分为3部分：

   1. 解析与填充符号表
   2. 插入式注解处理器的注解处理过程
   3. 分析与字节码生成过程

2. 生成 .class 文件

3. 由JVM转换为机器可以执行的二进制机器码

#### JDK 和 JRE

* JDK

  拥有 JRE 所拥有的一切，同时也拥有 javac 编译器 和 一些工具 （javadoc和jdb），它能够创建和编译程序

* JRE

  JRE 是 Java 运行时环境，它是运行 Java 程序所需的所有内容的集合，包括 Java 虚拟机、Java类库、Java命令和其他一些基础构件

## Java 和 C++ 的区别

* 都是面向对象的语言，都支持继承、封装和多态
* Java 不提供指针来访问内存，程序内存更加安全
* Java 的类都是单继承，C++ 支持多继承，Java的接口支持多继承
* Java 具有自动内存管理，不需要程序员手动释放无用内存

## 重载和重写的区别？构造器 Constructor 是否可被 override？

* 重载

  发生在同一个类中，方法名必须相同，参数类型不同，方法返回值和方法修饰符可以不同，发生在编译期

* 重写

  发生在父子类中，方法名必须相同，参数类型必须相同，方法返回值范围小于等于父类方法，方法修饰符范围大于或等于父类方法，抛出的异常范围小于等于父类方法

构造器不可被重写，但可以被重载，子类中默认调用父类的无参构造方法，如果想调用父类有参的构造方法，需用super显式的调用，但此时子类不会再默认的去调用父类的无参构造方法

## 谈谈Java面向对象编程的三大特性：封装、继承和多态

#### 封装

把一个对象的属性私有化，同时提供一些可以被外界访问的属性的方法

#### 继承

就是子类继承父类的特征和行为，使得子类对象（实例）具有父类域和方法，或子类从父类继承方法，使得子类具有父类相同的行为

**继承的一些特点**：

* 子类拥有父类对象所有的属性和方法（包括私有属性和私有方法），但是父类中的私有属性和私有方法子类是无法访问的，**只是拥有**
* 子类可以拥有自己的属性和方法，即子类可以对父类进行扩展
* 子类可以用自己的方法实现父类的方法

#### 多态

指程序中定义的引用变量所指向的具体类型和通过该引用变量发出的方法调用在编译时并不确定，而是在程序运行期间才确定，即一个引用变量到底会指向哪个类的实例对象，该引用变量发出的方法调用到底是哪个类中实现的方法，必须在由程序运行期间才能决定

在 Java 中有两种形式可以实现多态：继承和接口

## `String str="abcd"`与 `String str1=new String("acbd")`一样吗？str和str1相等吗？

不一样

* 第一种方式会先检查字符串常量池中有没有"abcd"，如果没有则会创建一个，并把 str 指向它，如果常量池中存在"abcd"，会把str直接指向常量池中的"abcd"
* 第二种方式会在堆内存中创建一个对象str1指向"abcd"

推荐使用第一种方式创建字符串

str和str1不相等，因为一个是堆内存中的 String 对象，一个是常量池中的 String 对象

## String StringBuffer 和 StringBuilder 的区别是什么？String 为什么是不可变的？

**可变性**：

String 类中使用 final 关键字修饰字符数组来保存字符串，`private final char value[]`，所以 String 对象是不可变的。而 Stringbuilder 和 StringBuffer 都继承自 AbstractStringBuilder 类，在 AbstractStringBuilder 中也是使用字符数组保存字符串 `char[] value` 但是没有用 final 关键字修饰，所以这两种对象都是可变的

StringBuilder 与 StringBuffer 的构造方法都是调用父类构造方法也就是 AbstractStringBuilder 实现的

**线程安全性**：

String 中的对象是不可变的，也就可以理解为常量，线程安全。StringBuffer 对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的。StringBuilder 并没有对方法进行加同步锁，所以是非线程安全的

**性能**：

每次对 String 类型进行改变的时候，都会生成一个新的 String 对象，然后将指针指向新的 String 对象。StringBuffer 每次都会对 StringBuffer 对象本身进行操作，而不是生成新的对象并改变对象引用。相同情况下使用 StringBuilder 相比使用 StringBuffer 仅能获得 10%~15% 左右的性能提升，但却要冒多线程不安全的风险。效率上 String 明显会比其他两种低

#### 总结：

1. 操作少量的数据: 适用String
2. 单线程操作字符串缓冲区下操作大量数据: 适用StringBuilder
3. 多线程操作字符串缓冲区下操作大量数据: 适用StringBuffer